---
phase: 01-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - TWL.Server/Persistence/Repositories/DbPlayerRepository.cs
  - TWL.Server/Persistence/Repositories/Queries/PlayerQueries.cs
  - TWL.Server/Persistence/IPlayerRepository.cs
  - TWL.Server/Persistence/FilePlayerRepository.cs
  - TWL.Server/Simulation/Program.cs
autonomous: true

must_haves:
  truths:
    - "Player data saves to PostgreSQL atomically using EF Core with transaction safety"
    - "Player data loads from PostgreSQL using Dapper with high-performance single-query read"
    - "FilePlayerRepository is removed and all player operations use PostgreSQL"
    - "Existing PlayerService flush loop works unchanged with the new repository"
    - "Complex nested data (inventory, equipment, pets, skills, quests) round-trips through JSONB without data loss"
  artifacts:
    - path: "TWL.Server/Persistence/Repositories/DbPlayerRepository.cs"
      provides: "Hybrid EF Core write + Dapper read implementation of IPlayerRepository"
      contains: "class DbPlayerRepository : IPlayerRepository"
    - path: "TWL.Server/Persistence/Repositories/Queries/PlayerQueries.cs"
      provides: "Dapper SQL queries and DTO for high-performance player loading"
      contains: "class PlayerQueries"
  key_links:
    - from: "TWL.Server/Simulation/Program.cs"
      to: "DbPlayerRepository"
      via: "DI registration replacing FilePlayerRepository"
      pattern: "AddSingleton.*IPlayerRepository.*DbPlayerRepository"
    - from: "DbPlayerRepository"
      to: "GameDbContext"
      via: "EF Core for SaveAsync writes"
      pattern: "GameDbContext|SaveChangesAsync"
    - from: "DbPlayerRepository"
      to: "NpgsqlDataSource"
      via: "Dapper for LoadAsync reads"
      pattern: "OpenConnectionAsync|QueryFirstOrDefaultAsync"
    - from: "PlayerService"
      to: "DbPlayerRepository"
      via: "IPlayerRepository interface (unchanged)"
      pattern: "_repo\\.SaveAsync|_repo\\.LoadAsync"
---

<objective>
Implement DbPlayerRepository with hybrid EF Core (writes) and Dapper (reads), swap DI registration from FilePlayerRepository, and remove the file-based implementation.

Purpose: Completes the PostgreSQL migration. After this plan, all player persistence uses ACID transactions via PostgreSQL instead of JSON files. The hybrid approach gives atomic writes (EF Core) with high-performance reads (Dapper), preparing for future market/guild features that need concurrent transaction safety.

Output: DbPlayerRepository handling all save/load operations, FilePlayerRepository removed, DI wired to new implementation.
</objective>

<execution_context>
@C:/Users/guido/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/guido/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md

@TWL.Server/Persistence/IPlayerRepository.cs
@TWL.Server/Persistence/FilePlayerRepository.cs
@TWL.Server/Persistence/PlayerSaveData.cs
@TWL.Server/Persistence/Services/PlayerService.cs
@TWL.Server/Persistence/Database/GameDbContext.cs
@TWL.Server/Persistence/Database/Entities/PlayerEntity.cs
@TWL.Server/Simulation/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DbPlayerRepository with EF Core writes and Dapper reads</name>
  <files>
    TWL.Server/Persistence/Repositories/DbPlayerRepository.cs
    TWL.Server/Persistence/Repositories/Queries/PlayerQueries.cs
  </files>
  <action>
    1. Create `TWL.Server/Persistence/Repositories/Queries/PlayerQueries.cs`:
       - Static class `PlayerQueries` in namespace `TWL.Server.Persistence.Repositories.Queries`
       - Contains SQL constant for loading a player with all data in a single query:
         ```sql
         SELECT
             player_id AS PlayerId,
             user_id AS UserId,
             name AS Name,
             hp AS Hp, sp AS Sp,
             level AS Level,
             rebirth_level AS RebirthLevel,
             exp AS Exp,
             exp_to_next_level AS ExpToNextLevel,
             stat_points AS StatPoints,
             str AS Str, con AS Con, int AS Int, wis AS Wis, agi AS Agi,
             element AS Element,
             gold AS Gold,
             premium_currency AS PremiumCurrency,
             daily_gift_accumulator AS DailyGiftAccumulator,
             last_gift_reset_date AS LastGiftResetDate,
             map_id AS MapId, x AS X, y AS Y,
             active_pet_instance_id AS ActivePetInstanceId,
             inventory_json AS InventoryJson,
             equipment_json AS EquipmentJson,
             bank_json AS BankJson,
             pets_json AS PetsJson,
             skills_json AS SkillsJson,
             world_flags_json AS WorldFlagsJson,
             processed_orders_json AS ProcessedOrdersJson,
             instance_lockouts_json AS InstanceLockoutsJson,
             quest_states_json AS QuestStatesJson,
             quest_progress_json AS QuestProgressJson,
             quest_flags_json AS QuestFlagsJson,
             quest_completion_times_json AS QuestCompletionTimesJson,
             quest_start_times_json AS QuestStartTimesJson,
             last_saved AS LastSaved
         FROM players
         WHERE user_id = @UserId
         ```
       - Internal DTO class `PlayerDto` with all properties matching the SELECT aliases (all scalar types + string for JSONB fields)

    2. Create `TWL.Server/Persistence/Repositories/DbPlayerRepository.cs`:
       - Class `DbPlayerRepository : IPlayerRepository` in namespace `TWL.Server.Persistence.Repositories`
       - Constructor takes `GameDbContext context` and `NpgsqlDataSource dataSource`
       - Inject `ILogger<DbPlayerRepository>` for error logging

       **SaveAsync(int userId, PlayerSaveData data):**
       - Uses EF Core for atomic writes
       - Query existing PlayerEntity by userId (no eager loading needed since JSONB is in same row)
       - If not found, create new PlayerEntity and Add to context
       - Map all scalar fields from `data.Character` to entity properties
       - Serialize JSONB fields using `System.Text.Json.JsonSerializer.Serialize()`:
         - `entity.InventoryJson = JsonSerializer.Serialize(data.Character.Inventory)`
         - Same for Equipment, Bank, Pets, Skills, WorldFlags, ProcessedOrders, InstanceLockouts
       - Serialize quest data from `data.Quests`:
         - `entity.QuestStatesJson = JsonSerializer.Serialize(data.Quests.States)`
         - Same for Progress, Flags, CompletionTimes, StartTimes
       - Set `entity.LastSaved = data.LastSaved` (or DateTime.UtcNow)
       - Call `await _context.SaveChangesAsync()`
       - Wrap in try/catch, log errors, rethrow
       - Do NOT use Serializable isolation for regular saves (unnecessary overhead). Default Read Committed is fine for single-player saves. Serializable is only needed for multi-party operations (market, guild bank) in future phases.

       **LoadAsync(int userId):**
       - Uses Dapper for high-performance reads
       - `await using var conn = await _dataSource.OpenConnectionAsync()`
       - Execute `PlayerQueries.LoadByUserId` SQL with `new { UserId = userId }`
       - Use `conn.QueryFirstOrDefaultAsync<PlayerDto>(sql, params)`
       - If null, return null
       - Map `PlayerDto` to `PlayerSaveData`:
         - Create `ServerCharacterData` with all scalar properties mapped
         - Deserialize each JSONB string to its typed collection using `JsonSerializer.Deserialize<T>()`
         - Use null-coalescing for safety: `JsonSerializer.Deserialize<List<Item>>(dto.InventoryJson) ?? new List<Item>()`
         - Create `QuestData` from quest JSON fields
       - Return assembled `PlayerSaveData`

       **Load(int userId):**
       - Synchronous wrapper: `return LoadAsync(userId).GetAwaiter().GetResult()`
       - Add `[Obsolete("Use LoadAsync instead")]` attribute to discourage sync usage

    IMPORTANT: Plan 01 registers `GameDbContext` via `AddDbContextFactory` (factory pattern). Since `DbPlayerRepository` is a singleton, it CANNOT inject a scoped/transient DbContext directly. Instead, inject `IDbContextFactory<GameDbContext>` and create short-lived contexts per operation.

    DbPlayerRepository constructor accepts `IDbContextFactory<GameDbContext>`:
    ```csharp
    public async Task SaveAsync(int userId, PlayerSaveData data)
    {
        await using var context = await _contextFactory.CreateDbContextAsync();
        // ... use context for this save operation
    }
    ```

    JsonSerializer options: use the same `JsonSerializerOptions` with `PropertyNameCaseInsensitive = true` to handle any casing mismatches between serialized JSON and the domain types. Create a static readonly field for reuse.
  </action>
  <verify>
    `dotnet build TWL.Server/TWL.Server.csproj` compiles without errors. DbPlayerRepository implements all 3 methods of IPlayerRepository.
  </verify>
  <done>
    DbPlayerRepository saves player data atomically via EF Core and loads via Dapper single-query. All JSONB fields serialize/deserialize correctly. IDbContextFactory pattern avoids captured context issues in singleton services.
  </done>
</task>

<task type="auto">
  <name>Task 2: Swap DI registration to DbPlayerRepository, update Program.cs, remove FilePlayerRepository</name>
  <files>
    TWL.Server/Simulation/Program.cs
    TWL.Server/Persistence/FilePlayerRepository.cs
    TWL.Server/Persistence/IPlayerRepository.cs
  </files>
  <action>
    1. Update `TWL.Server/Simulation/Program.cs`:
       - Add `using TWL.Server.Persistence.Repositories;`
       - Verify the EF Core registration is already `AddDbContextFactory` (set up by Plan 01):
         ```csharp
         svcs.AddDbContextFactory<GameDbContext>(options =>
             options.UseNpgsql(dataSource));
         ```
       - Replace the IPlayerRepository registration:
         ```csharp
         // OLD: svcs.AddSingleton<IPlayerRepository, FilePlayerRepository>();
         // NEW:
         svcs.AddSingleton<IPlayerRepository>(sp =>
             new DbPlayerRepository(
                 sp.GetRequiredService<IDbContextFactory<GameDbContext>>(),
                 sp.GetRequiredService<NpgsqlDataSource>(),
                 sp.GetRequiredService<ILogger<DbPlayerRepository>>()));
         ```
       - Add `using Microsoft.Extensions.Logging;` if not already present
       - Add `using Microsoft.EntityFrameworkCore;` if not already present

    2. Update `TWL.Server/Persistence/IPlayerRepository.cs`:
       - Add the `Delete` method for future cleanup needs (optional but good practice):
         No, keep the interface minimal - only add methods when needed. Leave IPlayerRepository unchanged.

    3. Delete `TWL.Server/Persistence/FilePlayerRepository.cs`:
       - Remove the file entirely. It is no longer referenced.
       - Search the codebase for any remaining references to `FilePlayerRepository` and remove them (imports, comments).
       - Check `TWL.Server/Simulation/Program.cs` does not reference it.

    4. Verify no other files reference `FilePlayerRepository`:
       ```bash
       grep -r "FilePlayerRepository" TWL.Server/ --include="*.cs"
       ```
       If any references remain, update them.

    5. Build and verify the full solution compiles:
       ```bash
       dotnet build
       ```

    6. Verify the server starts and connects to PostgreSQL:
       ```bash
       dotnet run --project TWL.Server
       ```
       The server should start without errors. If Docker PostgreSQL is not running, the server will log a connection error - that's expected behavior, not a code bug.

    IMPORTANT: Do NOT modify `PlayerService.cs` at all. It depends only on `IPlayerRepository` interface, which `DbPlayerRepository` now implements. The flush loop, session management, and save/load flow all work unchanged through the interface.

    IMPORTANT: Do NOT modify `DbService.cs`. It still handles authentication (`CheckLoginAsync`) via raw Npgsql. It will be migrated to use GameDbContext in a future phase. Both `DbService` and `GameDbContext` can coexist because they share the same `NpgsqlDataSource` connection pool.
  </action>
  <verify>
    1. `dotnet build` compiles the full solution without errors.
    2. `grep -r "FilePlayerRepository" TWL.Server/ --include="*.cs"` returns no results.
    3. `FilePlayerRepository.cs` no longer exists on disk.
    4. Server starts without errors (with Docker PostgreSQL running).
    5. Login + save cycle works: connect a client, login, the server saves player data to PostgreSQL instead of JSON files.
  </verify>
  <done>
    FilePlayerRepository is deleted. All player persistence flows through DbPlayerRepository -> PostgreSQL. PlayerService works unchanged via IPlayerRepository interface. Server starts and persists data to PostgreSQL. No JSON save files are created for new sessions.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` compiles cleanly (zero errors, zero warnings related to persistence)
2. `FilePlayerRepository.cs` does not exist
3. No code references `FilePlayerRepository`
4. DI resolves `IPlayerRepository` as `DbPlayerRepository`
5. Server starts, connects to PostgreSQL, and can save/load player data
6. PlayerService flush loop saves dirty sessions to PostgreSQL every 30 seconds
7. JSONB data round-trips correctly: save a player with inventory items, load them back, verify item data matches
</verification>

<success_criteria>
- Player data persists in PostgreSQL with EF Core atomic writes (INFRA-01, INFRA-02)
- Player data loads from PostgreSQL with Dapper high-performance reads (INFRA-03)
- FilePlayerRepository is completely removed (INFRA-01 success criterion 4)
- PlayerService flush loop works unchanged through IPlayerRepository interface
- Complex nested data (inventory, equipment, pets, skills, quests, world flags) survives JSONB round-trip
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md`
</output>
