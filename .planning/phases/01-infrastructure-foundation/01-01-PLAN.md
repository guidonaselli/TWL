---
phase: 01-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TWL.Server/TWL.Server.csproj
  - TWL.Server/Persistence/Database/GameDbContext.cs
  - TWL.Server/Persistence/Database/Configurations/PlayerConfiguration.cs
  - TWL.Server/Persistence/Database/Configurations/AccountConfiguration.cs
  - TWL.Server/Simulation/Program.cs
autonomous: true

must_haves:
  truths:
    - "EF Core GameDbContext connects to PostgreSQL and can create/migrate schema"
    - "NpgsqlDataSource provides pooled connections shared by EF Core and future Dapper queries"
    - "EF Core migration tracks schema version and can roll forward/backward"
    - "Player entity maps complex nested data (inventory, equipment, pets, skills, quests) to JSONB columns"
  artifacts:
    - path: "TWL.Server/Persistence/Database/GameDbContext.cs"
      provides: "EF Core DbContext with DbSet<PlayerEntity> and DbSet<AccountEntity>"
      contains: "class GameDbContext"
    - path: "TWL.Server/Persistence/Database/Configurations/PlayerConfiguration.cs"
      provides: "Fluent API mapping for Player entity with JSONB columns"
      contains: "IEntityTypeConfiguration<PlayerEntity>"
    - path: "TWL.Server/Persistence/Database/Configurations/AccountConfiguration.cs"
      provides: "Fluent API mapping for Account entity matching existing accounts table"
      contains: "IEntityTypeConfiguration<AccountEntity>"
  key_links:
    - from: "TWL.Server/Simulation/Program.cs"
      to: "GameDbContext"
      via: "DI registration with NpgsqlDataSource"
      pattern: "AddDbContextFactory.*GameDbContext"
    - from: "GameDbContext"
      to: "PostgreSQL"
      via: "NpgsqlDataSource connection pooling"
      pattern: "UseNpgsql"
---

<objective>
Set up EF Core 10 infrastructure with GameDbContext, entity configurations, NpgsqlDataSource connection pooling, and initial database migration.

Purpose: Creates the foundation layer that Plan 02 builds on. Without GameDbContext and entity mappings, no repository can use EF Core for writes or share the connection pool with Dapper for reads.

Output: GameDbContext registered in DI, entity configurations for Players and Accounts, initial migration generated, NpgsqlDataSource singleton providing pooled connections.
</objective>

<execution_context>
@C:/Users/guido/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/guido/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md

@TWL.Server/TWL.Server.csproj
@TWL.Server/Persistence/Database/DbService.cs
@TWL.Server/Persistence/PlayerSaveData.cs
@TWL.Server/Simulation/Program.cs
@TWL.Server/Persistence/ServerConfig.json
@docker-compose.yml
@db/init.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NuGet packages and create entity models with JSONB-mapped configurations</name>
  <files>
    TWL.Server/TWL.Server.csproj
    TWL.Server/Persistence/Database/Entities/PlayerEntity.cs
    TWL.Server/Persistence/Database/Entities/AccountEntity.cs
    TWL.Server/Persistence/Database/Configurations/PlayerConfiguration.cs
    TWL.Server/Persistence/Database/Configurations/AccountConfiguration.cs
  </files>
  <action>
    1. Add NuGet packages to TWL.Server.csproj:
       - `Npgsql.EntityFrameworkCore.PostgreSQL` version 10.0.0
       - `Microsoft.EntityFrameworkCore.Design` version 10.0.0 (for migrations tooling)
       - `Dapper` version 2.1.35 (needed by Plan 02 but install now to avoid csproj conflicts)

    2. Create `TWL.Server/Persistence/Database/Entities/PlayerEntity.cs`:
       - Class `PlayerEntity` in namespace `TWL.Server.Persistence.Database.Entities`
       - Properties matching `ServerCharacterData` fields from `PlayerSaveData.cs`:
         - `int PlayerId` (PK, auto-increment)
         - `int UserId` (FK to accounts, unique)
         - `string Name` (max 50 chars)
         - `int Hp`, `int Sp`, `int Level`, `int RebirthLevel`, `int Exp`, `int ExpToNextLevel`
         - `int StatPoints`, `int Str`, `int Con`, `int Int`, `int Wis`, `int Agi`
         - `int Element` (stored as int, maps to TWL.Shared.Domain.Characters.Element enum)
         - `int Gold`, `long PremiumCurrency`
         - `long DailyGiftAccumulator`, `DateTime LastGiftResetDate`
         - `int MapId`, `float X`, `float Y`
         - `string ActivePetInstanceId` (nullable)
       - JSONB-mapped properties (store as `string` with JSONB column type, serialized/deserialized by the repository):
         - `string InventoryJson` (maps to List<Item>)
         - `string EquipmentJson` (maps to List<Item>)
         - `string BankJson` (maps to List<Item>)
         - `string PetsJson` (maps to List<ServerPetData>)
         - `string SkillsJson` (maps to List<SkillMasteryData>)
         - `string WorldFlagsJson` (maps to HashSet<string>)
         - `string ProcessedOrdersJson` (maps to HashSet<string>)
         - `string InstanceLockoutsJson` (maps to Dictionary<string, DateTime>)
         - `string QuestStatesJson` (maps to Dictionary<int, QuestState>)
         - `string QuestProgressJson` (maps to Dictionary<int, List<int>>)
         - `string QuestFlagsJson` (maps to HashSet<string>)
         - `string QuestCompletionTimesJson` (maps to Dictionary<int, DateTime>)
         - `string QuestStartTimesJson` (maps to Dictionary<int, DateTime>)
       - `DateTime LastSaved`
       - Navigation: `AccountEntity Account` (optional, for FK relationship)

    3. Create `TWL.Server/Persistence/Database/Entities/AccountEntity.cs`:
       - Class `AccountEntity` in same namespace
       - Properties matching existing `accounts` table exactly:
         - `int UserId` (PK, maps to `user_id`)
         - `string Username` (max 50, unique)
         - `string PassHash` (max 128)
       - Navigation: `PlayerEntity? Player` (one-to-one, optional)

    4. Create `TWL.Server/Persistence/Database/Configurations/PlayerConfiguration.cs`:
       - Implements `IEntityTypeConfiguration<PlayerEntity>`
       - Maps to table `players` (snake_case column names using `.HasColumnName()`)
       - PK on `PlayerId` with `UseIdentityByDefaultColumn()`
       - FK to `accounts` on `UserId` with CASCADE delete
       - Unique index on `UserId` (one player per account)
       - All JSONB string properties: `.HasColumnType("jsonb")` with default value `"[]"` for arrays and `"{}"` for objects
       - `Name` has `.HasMaxLength(50).IsRequired()`
       - `LastSaved` defaults to `DateTime.UtcNow`

    5. Create `TWL.Server/Persistence/Database/Configurations/AccountConfiguration.cs`:
       - Implements `IEntityTypeConfiguration<AccountEntity>`
       - Maps to table `accounts` (must match existing table exactly: `user_id`, `username`, `pass_hash`)
       - PK on `UserId` with `UseIdentityByDefaultColumn()`
       - `Username` has `.HasMaxLength(50).IsRequired()` with unique index
       - `PassHash` has `.HasMaxLength(128).IsRequired()`
       - One-to-one relationship with `PlayerEntity` via `UserId`

    IMPORTANT: Use snake_case for all column names (`.HasColumnName("snake_case")`) to match existing PostgreSQL conventions. The existing `accounts` table uses `user_id`, `username`, `pass_hash`.
  </action>
  <verify>
    Run `dotnet build TWL.Server/TWL.Server.csproj` and confirm no compilation errors. Verify NuGet packages restored successfully.
  </verify>
  <done>
    All entity classes compile, configurations implement IEntityTypeConfiguration correctly, NuGet packages installed. Column mappings use snake_case matching PostgreSQL conventions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GameDbContext, register NpgsqlDataSource and EF Core in DI, generate initial migration</name>
  <files>
    TWL.Server/Persistence/Database/GameDbContext.cs
    TWL.Server/Simulation/Program.cs
  </files>
  <action>
    1. Create `TWL.Server/Persistence/Database/GameDbContext.cs`:
       - Class `GameDbContext : DbContext` in namespace `TWL.Server.Persistence.Database`
       - Constructor accepting `DbContextOptions<GameDbContext> options`
       - `DbSet<PlayerEntity> Players { get; set; }`
       - `DbSet<AccountEntity> Accounts { get; set; }`
       - Override `OnModelCreating` to apply configurations from assembly:
         ```csharp
         modelBuilder.ApplyConfigurationsFromAssembly(typeof(GameDbContext).Assembly);
         ```
       - Add `using TWL.Server.Persistence.Database.Entities;`

    2. Update `TWL.Server/Simulation/Program.cs` DI registration:
       - Add `using Npgsql;` and `using TWL.Server.Persistence.Database;` and `using Microsoft.EntityFrameworkCore;`
       - BEFORE the existing `DbService` registration, add NpgsqlDataSource as singleton:
         ```csharp
         var connectionString = ctx.Configuration.GetConnectionString("PostgresConn");
         var dataSourceBuilder = new NpgsqlDataSourceBuilder(connectionString);
         var dataSource = dataSourceBuilder.Build();
         svcs.AddSingleton(dataSource);
         ```
       - After NpgsqlDataSource, register GameDbContext using the **factory pattern** (required because Plan 02's DbPlayerRepository is a singleton and cannot inject a scoped/transient DbContext directly â€” the factory creates short-lived contexts per operation):
         ```csharp
         svcs.AddDbContextFactory<GameDbContext>(options =>
             options.UseNpgsql(dataSource));
         ```
       - Keep existing `DbService` registration unchanged (it will be deprecated in a later phase, still used for auth).

    3. Install EF Core CLI tools if not already available:
       ```bash
       dotnet tool install --global dotnet-ef --version 10.0.0
       ```

    4. Generate initial migration. The migration MUST handle the fact that the `accounts` table already exists in PostgreSQL. Use the `--output-dir` flag to place migrations in the Database folder:
       ```bash
       dotnet ef migrations add InitialPlayerSchema --project TWL.Server --output-dir Persistence/Database/Migrations
       ```

    5. After migration is generated, review and EDIT the migration file:
       - The `Up()` method must NOT create the `accounts` table (it already exists). Wrap the accounts table creation in a check or remove it entirely, keeping only the `players` table creation.
       - Use `migrationBuilder.Sql("...")` to check if table exists:
         ```csharp
         // Skip accounts table - already exists in PostgreSQL
         // Only create players table with full schema
         ```
       - The `Down()` method should only drop `players` (not `accounts` - that's managed by DbService).
       - Verify the players table has all JSONB columns with correct defaults.

    6. Apply the migration to verify it works:
       ```bash
       dotnet ef database update --project TWL.Server
       ```
       Note: This requires the Docker PostgreSQL container to be running (`docker-compose up -d`). If the container is not running, document the command but do not fail the task - the migration file itself is the artifact.

    IMPORTANT: Do NOT remove or modify the existing `DbService` singleton registration. It is still used for authentication (`CheckLoginAsync`). Both `DbService` and `GameDbContext` will coexist temporarily. `DbService` will be refactored in a future phase.

    NOTE: The factory pattern (`AddDbContextFactory`) is used instead of `AddDbContext` because Plan 02's `DbPlayerRepository` is registered as a singleton. A singleton cannot inject a scoped DbContext. The factory creates a fresh DbContext per operation via `_contextFactory.CreateDbContextAsync()`, which avoids stale change tracker state between saves.
  </action>
  <verify>
    1. `dotnet build TWL.Server/TWL.Server.csproj` compiles without errors.
    2. Migration file exists at `TWL.Server/Persistence/Database/Migrations/`.
    3. If Docker is running: `dotnet ef database update --project TWL.Server` succeeds and `\dt` in psql shows the `players` table with JSONB columns.
    4. Verify the server starts without errors: `dotnet run --project TWL.Server` (can Ctrl+C after startup).
  </verify>
  <done>
    GameDbContext is registered in DI with NpgsqlDataSource pooling. Initial migration creates players table with all JSONB columns. Existing accounts table is preserved. Server starts without errors. Migration can be rolled back with `dotnet ef database update 0`.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TWL.Server/TWL.Server.csproj` compiles cleanly
2. EF Core migration file exists in `TWL.Server/Persistence/Database/Migrations/`
3. `GameDbContext` is registered in DI and can resolve
4. `NpgsqlDataSource` is registered as singleton
5. Existing `DbService` auth still works (not modified)
6. Server starts without errors
</verification>

<success_criteria>
- GameDbContext with PlayerEntity and AccountEntity configurations compiles and is DI-registered
- NpgsqlDataSource provides connection pooling for both EF Core and future Dapper usage
- Initial migration creates full players table schema with JSONB columns without breaking existing accounts table
- Migration is version-controlled and reversible (Up/Down methods both work)
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md`
</output>
