---
phase: 05-guild-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TWL.Server/Simulation/Managers/IGuildService.cs
  - TWL.Server/Simulation/Managers/GuildManager.cs
  - TWL.Shared/Domain/DTO/GuildDTOs.cs
  - TWL.Shared/Net/Messages/ClientMessageType.cs
  - TWL.Shared/Net/Messages/ServerMessageType.cs
  - TWL.Shared/Net/Network/Opcode.cs
  - TWL.Server/Simulation/Networking/ClientSession.cs
  - TWL.Server/Simulation/Program.cs
  - TWL.Tests/Guild/GuildLifecycleTests.cs
autonomous: true

must_haves:
  truths:
    - "Players can create guilds with unique names and configured creation fee enforcement"
    - "Players can invite others to guild and receive accept/decline outcomes"
    - "Guild members can leave and authorized guild members can kick members"
  artifacts:
    - path: "TWL.Server/Simulation/Managers/GuildManager.cs"
      provides: "Server-authoritative guild lifecycle state and membership operations"
      contains: "class GuildManager"
    - path: "TWL.Shared/Domain/DTO/GuildDTOs.cs"
      provides: "Canonical request/response payloads for guild lifecycle operations"
      contains: "CreateGuildRequest"
    - path: "TWL.Server/Simulation/Networking/ClientSession.cs"
      provides: "Opcode handlers for guild create/invite/accept/decline/leave/kick flows"
      contains: "HandleGuild"
  key_links:
    - from: "TWL.Shared/Net/Network/Opcode.cs"
      to: "TWL.Server/Simulation/Networking/ClientSession.cs"
      via: "guild opcodes dispatch to guild handlers"
      pattern: "GuildCreate|GuildInvite|GuildAccept|GuildDecline|GuildLeave|GuildKick"
    - from: "TWL.Server/Simulation/Program.cs"
      to: "TWL.Server/Simulation/Managers/GuildManager.cs"
      via: "DI registration injects guild service into runtime session handling"
      pattern: "AddSingleton<IGuildService>|AddSingleton<GuildManager>"
---

<objective>
Implement the guild lifecycle foundation: guild creation, membership invite flow, leave/kick flow, and core network contracts.

Purpose: This establishes GLD-01, GLD-02, and GLD-03 while creating the protocol backbone needed for rank, chat, and storage plans.
Output: Guild service + guild DTOs/opcodes + server session handlers + deterministic lifecycle tests.
</objective>

<execution_context>
@~/.codex/get-shit-done/workflows/execute-plan.md
@~/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-guild-system/05-RESEARCH.md

@TWL.Server/Simulation/Managers/TradeManager.cs
@TWL.Server/Simulation/Managers/EconomyManager.cs
@TWL.Server/Simulation/Networking/ClientSession.cs
@TWL.Server/Simulation/Networking/ServerCharacter.cs
@TWL.Server/Simulation/Program.cs
@TWL.Shared/Net/Messages/ClientMessageType.cs
@TWL.Shared/Net/Messages/ServerMessageType.cs
@TWL.Shared/Net/Network/Opcode.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create guild lifecycle domain service and protocol contracts</name>
  <files>
    TWL.Server/Simulation/Managers/IGuildService.cs
    TWL.Server/Simulation/Managers/GuildManager.cs
    TWL.Shared/Domain/DTO/GuildDTOs.cs
    TWL.Shared/Net/Messages/ClientMessageType.cs
    TWL.Shared/Net/Messages/ServerMessageType.cs
    TWL.Shared/Net/Network/Opcode.cs
  </files>
  <action>
    1. Add `IGuildService` and `GuildManager` with authoritative lifecycle operations for:
       - create guild (unique name check, creation fee check)
       - invite / accept / decline
       - leave guild
       - kick member (authorization stub integrated with upcoming rank plan)

    2. Add strongly typed guild DTO contracts for requests, responses, and membership broadcasts.

    3. Extend message/opcode enums to include guild lifecycle operations while preserving compatibility with existing packet conventions.
  </action>
  <verify>
    `dotnet build TWL.Shared/TWL.Shared.csproj` and `dotnet build TWL.Server/TWL.Server.csproj` succeed.
  </verify>
  <done>
    Guild lifecycle operations are represented as compile-safe server contracts and transport-level messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire guild lifecycle handlers into session flow and DI</name>
  <files>
    TWL.Server/Simulation/Networking/ClientSession.cs
    TWL.Server/Simulation/Program.cs
    TWL.Server/Simulation/Networking/ServerCharacter.cs
  </files>
  <action>
    1. Register guild service in DI and inject it into `ClientSession`.

    2. Add session handlers for guild create/invite/accept/decline/leave/kick opcodes, including appropriate response and member-broadcast events.

    3. Ensure guild membership changes update `ServerCharacter.GuildId` consistently and trigger quest progression hooks where applicable.
  </action>
  <verify>
    Run `dotnet test TWL.Tests/TWL.Tests.csproj --filter "FullyQualifiedName~PvPAndGatingTests|FullyQualifiedName~GuildLifecycleTests"`.
  </verify>
  <done>
    Guild lifecycle operations execute through network handlers and synchronize membership state correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add deterministic guild lifecycle tests</name>
  <files>
    TWL.Tests/Guild/GuildLifecycleTests.cs
  </files>
  <action>
    1. Add `GuildLifecycleTests` covering:
       - guild create success
       - duplicate guild name rejection
       - insufficient creation fee rejection
       - invite + accept flow
       - invite + decline flow
       - leave flow
       - authorized kick flow

    2. Keep tests independent and deterministic (explicit actor IDs and state setup).
  </action>
  <verify>
    `dotnet test TWL.Tests/TWL.Tests.csproj --filter "FullyQualifiedName~GuildLifecycleTests"`
  </verify>
  <done>
    Guild lifecycle behavior is test-backed and regressions fail fast.
  </done>
</task>

</tasks>

<verification>
- [ ] Guild creation enforces unique name and creation fee checks
- [ ] Invite/accept/decline/leave/kick flows route through `ClientSession`
- [ ] Membership updates set `GuildId` consistently on affected characters
- [ ] Guild lifecycle tests pass
</verification>

<success_criteria>
- GLD-01, GLD-02, and GLD-03 are implemented at server-contract level
- Guild lifecycle is server-authoritative and network-addressable
- Guild foundation is ready for rank, chat, and storage extensions
</success_criteria>

<output>
After completion, create `.planning/phases/05-guild-system/05-01-SUMMARY.md`
</output>
