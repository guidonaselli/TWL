---
phase: 02-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TWL.Shared/Net/Network/NetMessage.cs
  - TWL.Server/Security/ReplayGuard.cs
  - TWL.Server/Security/ReplayGuardOptions.cs
  - TWL.Server/Simulation/Networking/ClientSession.cs
  - TWL.Server/Simulation/Networking/NetworkServer.cs
  - TWL.Server/Simulation/Program.cs
  - TWL.Tests/Security/ReplayGuardTests.cs
  - TWL.Tests/Security/ClientSessionReplayProtectionTests.cs
autonomous: true

must_haves:
  truths:
    - "A duplicate packet nonce for the same session is rejected and never reaches opcode handlers"
    - "A packet older than 30 seconds is rejected"
    - "A fresh packet with unique nonce still processes normally"
    - "Replay rejections are logged with correlation metadata"
  artifacts:
    - path: "TWL.Server/Security/ReplayGuard.cs"
      provides: "Reusable replay validation service with nonce cache and freshness checks"
      contains: "class ReplayGuard"
    - path: "TWL.Server/Simulation/Networking/ClientSession.cs"
      provides: "Replay validation gate before opcode dispatch"
      contains: "HandleMessageAsync"
    - path: "TWL.Shared/Net/Network/NetMessage.cs"
      provides: "Transport metadata fields for nonce and timestamp"
      contains: "Nonce"
  key_links:
    - from: "TWL.Shared/Net/Network/NetMessage.cs"
      to: "TWL.Server/Security/ReplayGuard.cs"
      via: "nonce/timestamp payload validated in server gate"
      pattern: "Nonce|TimestampUtc"
    - from: "TWL.Server/Simulation/Networking/ClientSession.cs"
      to: "TWL.Server/Security/ReplayGuard.cs"
      via: "pre-dispatch replay check"
      pattern: "_replayGuard"
---

<objective>
Implement packet replay protection using nonce + timestamp validation with a strict 30-second window.

Purpose: This plan delivers SEC-02 and establishes the packet trust boundary all later hardening depends on.
Output: NetMessage carries replay metadata, ClientSession validates replay/freshness before handler dispatch, and security tests prove duplicate/stale rejection.
</objective>

<execution_context>
@~/.codex/get-shit-done/workflows/execute-plan.md
@~/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-security-hardening/02-RESEARCH.md

@TWL.Shared/Net/Network/NetMessage.cs
@TWL.Server/Simulation/Networking/ClientSession.cs
@TWL.Server/Simulation/Networking/NetworkServer.cs
@TWL.Server/Security/SecurityLogger.cs
@TWL.Server/Security/RateLimiter.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add replay metadata to network envelope with backward-safe parsing</name>
  <files>
    TWL.Shared/Net/Network/NetMessage.cs
  </files>
  <action>
    1. Extend `NetMessage` with replay metadata fields:
       - `string Nonce`
       - `DateTime TimestampUtc`
       - optional `long Sequence` (if needed for future ordering checks)

    2. Keep deserialization backward-safe:
       - If legacy clients omit new fields, deserialize safely and mark message invalid later in validation gate (do not crash JSON parsing)

    3. Ensure serialization/deserialization options remain case-insensitive and no breaking changes are introduced for existing opcode payloads.
  </action>
  <verify>
    Build with `dotnet build TWL.Shared/TWL.Shared.csproj` and run serialization/deserialization smoke checks in tests.
  </verify>
  <done>
    NetMessage supports nonce/timestamp metadata and still deserializes existing payload structure without runtime exceptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ReplayGuard and enforce it before opcode resolution</name>
  <files>
    TWL.Server/Security/ReplayGuardOptions.cs
    TWL.Server/Security/ReplayGuard.cs
    TWL.Server/Simulation/Networking/ClientSession.cs
    TWL.Server/Simulation/Networking/NetworkServer.cs
    TWL.Server/Simulation/Program.cs
  </files>
  <action>
    1. Create `ReplayGuardOptions` with at least:
       - `AllowedClockSkewSeconds` (default 30)
       - `NonceTtlSeconds`
       - `MaxNoncesPerSession`

    2. Create `ReplayGuard` service:
       - API like `Validate(userId/sessionId, nonce, timestampUtc, out reason)`
       - Reject empty nonce/timestamp
       - Reject stale/future timestamps outside allowed skew
       - Reject nonce replay for same user/session within TTL
       - Use bounded in-memory cache per user/session to avoid unbounded growth

    3. Inject and enforce in `ClientSession.HandleMessageAsync` BEFORE switch dispatch:
       - If invalid, log `SecurityLogger.LogSecurityEvent("ReplayRejected", ...)`
       - Return without executing opcode handlers

    4. Wire ReplayGuard through `NetworkServer` and `Program.cs` DI registrations.

    5. Keep rate-limiter behavior unchanged; replay guard is an additional gate, not a replacement.
  </action>
  <verify>
    `dotnet build TWL.Server/TWL.Server.csproj` passes and server starts with ReplayGuard resolved from DI.
  </verify>
  <done>
    Replay and stale packets are rejected in ClientSession before business handlers, with structured security logs for diagnostics.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add security tests for replay window and duplicate nonce handling</name>
  <files>
    TWL.Tests/Security/ReplayGuardTests.cs
    TWL.Tests/Security/ClientSessionReplayProtectionTests.cs
  </files>
  <action>
    1. Add `ReplayGuardTests` covering:
       - Accept fresh unique nonce
       - Reject duplicate nonce for same session
       - Reject stale timestamp (>30 seconds)
       - Reject invalid/missing nonce
       - Allow same nonce across different sessions only if policy explicitly permits it

    2. Add `ClientSessionReplayProtectionTests` (unit or lightweight integration) proving:
       - Rejected packets do not invoke handlers
       - Security event is emitted for rejection

    3. Keep tests deterministic (fixed clock abstraction if needed).
  </action>
  <verify>
    `dotnet test TWL.Tests/TWL.Tests.csproj --filter "FullyQualifiedName~Replay"` passes.
  </verify>
  <done>
    Replay protection behavior is codified in tests and fails loudly on regressions.
  </done>
</task>

</tasks>

<verification>
- [ ] `dotnet build TWL.Server/TWL.Server.csproj` succeeds
- [ ] Replay tests pass
- [ ] Duplicate nonce and stale timestamp are rejected pre-dispatch
- [ ] Security log includes replay rejection event with correlation context
</verification>

<success_criteria>
- SEC-02 is implemented with server-enforced nonce + timestamp checks
- Replay validation occurs before opcode handler dispatch
- Rejection reasons are observable through tests and security logs
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-hardening/02-01-SUMMARY.md`
</output>
